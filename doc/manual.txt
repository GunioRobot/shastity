= shastity user's manual

NOTE: This is a work-in-progress. shastity has not yet been released
with the intent to be used by end-users, and this manual is not useful
yet.

== Introduction

shastity is a command line based backup software which provides the
ability to backup local file system contents to a variety of storage
backends. It is specifically designed to play well with eentually
consistent storage such as Amazon S3. It also supports encryption
(hence the name) of backed up data to allow for backups to
semi-trusted or untrusted storage. All backed up file conents is
stored in a block-wise fashion with hash-based de-duplication.

Just to give a quick couple of examples, in the simplest of cases,
backing up all of /home/username to a directory
/mnt/backup/home_username is as simple as:

  shastity persist /home/username dir:/mnt/backup/home_username

Or if you prefer to backup to the Amazon S3 service:

  shastity persist /home/username s3:bucket.base.name

(the S3 example requires appropriate AWS authentication information to
be present in environment variables or the shastity configuration).

This user manual will attempt to document shastity with a fair bit of
completeness, such that a reasonably experienced Unix admin can not
only use shastity, but understand the fundamental concepts and its
storage model.

Reasonable documentation, especially of backup tools, is important. If
you feel sections of this manual are incomplete or unclear, please do
file a bug (TODO: explain how). The target audience is that of people
with some reasonable level of experience with Unix-like operating
systems (working at the command line and editing configuration files)>

== Understanding the storage model

This section is not strictly necessary to use shastity. If you just
want to get it running to try it ASAP, you may want to skip this
section and return to it later. It is however highly recommended that
this section be read before using shastity in a production
environment.

Also, while this section will try to give some information on general
concepts such as hashing and content addressable storage, its primary
purpose is documenting how shastity uses these technologies. Users are
encouraged to read other material on cryptographic hashes, content
addressable storage, and de-duplication. TODO: provide some references

=== Content addressable storage ===

shastity uses "content addressable storage" for storing the contents
of files (in a block-wise fashion - more on that later).

With content addressable storage, the content determines where to find
(or put) the data. For example, in a content addressable storage
system that uses files in a directory, the text "hello world" might be
stored in the file:

  6f5902ac237024bdd0c176cb93063dc4

This is determined only by the contents of the file (there is no
separate piece of information that says that the text "hello world" is
stored in that file; it is determined solely based on the text
itself).
   
In order to accomplish the mapping from content ("hello world" above)
to storage location (the file 6f5902ac237024bdd0c176cb93063dc4 above),
a cryptographic hashing algorithm is used. In the above example, MD5
was used for brevity, though shastity by default uses SHA-512.

(Please Google for "cryptographic hash" if the above does not make
sense to you.)

=== De-duplication ===

In the example from the previous section, not only do you know that
the text "hello world" is always stored in the file
6f5902ac237024bdd0c176cb93063dc4, you also know to a very high degree
of certainty that you will not encounter any other text that is
supposed to be stored in the same file. This is a property of the
cryptographic hashing.

If we make the assumption that the probability of encountering a hash
collision is so low that we can consider it zero for practical
purposes, we can do de-duplication of data. In other words, whenever
we have the need to store the text "hello world" we can check whether
we already have that data stored solely based on the names of the
files in our storage system. If we do, we're done.

The result is that we will only ever store a single copy of "hello
world", regardless of how many times we asked our storage system to
store that data.

(It is important to note that the optimization only works for
identical data. For example, storage of the string "hello there,
world" is not helped by the fact that we have already stored "hello
world".)

=== Block-based storage ===

shastity stores file contents as blocks of data. For example, suppose
the block size is 6 bytes. In the preceding example, the text "hello
world" would then be stored as two blocks:

  "hello " -> 1a77a8341bddc4b45418f9c30e7102b4
  "world"  -> 591785b794601e212b260e25925636fd

The contents of the file can then be described as:

  The block 1a77a8341bddc4b45418f9c30e7102b4 followed by
  the block 591785b794601e212b260e25925636fd.

Let us make that a bit more terse and add some meta-data about the
file and we get something like:

  -rwxr-xr-x /home/username/mbox 1a77a8341bddc4b45418f9c30e7102b4 591785b794601e212b260e25925636fd

The above example is not identical to how shastity stores information
about files, but it is pretty similar. As you can see it is a highly
human-readable description of file meta data, with contents being
expressed in terms of references to stored blocks - by their identity.

To be clear, in real life the block size will be much larger than that
used in the examples. The expectation is that block sizes in the
ballpark of 1 MB will be used.
